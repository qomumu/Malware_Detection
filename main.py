#!/usr/bin/env python
import sys
import classifier
import lightgbm as lgb
import os
import time
import hashlib
import filetype
import win32file
import win32con
import base64
from PyQt5.QtCore import QDateTime, Qt, QTimer, QSize, QThread, QWaitCondition, QMutex, pyqtSignal, QObject, QRectF
from PyQt5.QtGui import QIcon, QPixmap, QImage, QPainter, QPainterPath, QColor
from PyQt5.QtWidgets import (QApplication, QCheckBox, QComboBox, QDateTimeEdit,QFileDialog,QToolButton,
                             QDial, QDialog, QGridLayout, QGroupBox, QHBoxLayout, QLabel, QLineEdit,
                             QProgressBar, QPushButton, QRadioButton, QScrollBar, QSizePolicy,
                             QSlider, QSpinBox, QStyleFactory, QTableWidget, QTabWidget, QTextEdit,
                             QVBoxLayout, QWidget, QMainWindow, QSystemTrayIcon, QSpacerItem, QMenu, QAction, QStyle,
                             qApp, QGraphicsDropShadowEffect, QListWidget, QListWidgetItem, QTextBrowser)

ACTIONS = {
  1 : "Created",
  2 : "Deleted",
  3 : "Updated",
  4 : "Renamed from something",
  5 : "Renamed to something"
}

FILE_LIST_DIRECTORY = win32con.GENERIC_READ | win32con.GENERIC_WRITE
path_to_watch = "C:\\"
hDir = win32file.CreateFile (
  path_to_watch,
  FILE_LIST_DIRECTORY,
  win32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE,
  None,
  win32con.OPEN_EXISTING,
  win32con.FILE_FLAG_BACKUP_SEMANTICS,
  None
)
check_box = None
tray_icon = None

def filetype_scan(filepath):
    try:
        kind = filetype.guess(filepath)
        return kind.extension
    except Exception as e:
        # print(e)
        return 0

def filehash_signatures(hash):
    f = open("./statics/malware.sig", "a", encoding="utf-8")
    f.write(hash + "\n")
    f.close()

def sig_match(filesig):
    flag = 0
    f = open("./statics/malware.sig", "r", encoding="utf-8")
    for line in f:
        if line.strip('\n') == filesig:
            flag = 1
            break
    return flag

class Thread_QuickScan(QThread):
    Scanlog = pyqtSignal(str)
    status_scan = pyqtSignal(str,int,int,list)
    sign = 0
    def __init__(self):
        super(Thread_QuickScan,self).__init__()

    def run(self):
        path_list = ["C:/windows/System32","C:/windows/SysWOW64"]
        count_files = 0
        count_bad = 0
        malwarelist = ['已清除以下恶意软件:']
        starttime = time.time()
        lgbm_model = lgb.Booster(model_file="model.txt")
        self.Scanlog.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + "开始快速扫描............................")
        for full_path in path_list:
            for root, dirs,files in os.walk(full_path):
                if self.sign == 1:
                    break
                for file in files:
                    try:
                        if self.sign == 1:
                            break
                        dir2file = os.path.join(root, file)
                        size = os.path.getsize(dir2file)
                        winlist = dir2file.split('\\')
                        newPath = '/'.join(winlist)
                        count_files = count_files + 1
                        file_extension = filetype_scan(newPath)
                        if size <= 47185920:
                            if file_extension != 0 and file_extension == 'exe':
                                suffix = os.path.splitext(file)[1]
                                if suffix == '.exe' or '.' not in file:
                                    putty_data = open(newPath, "rb").read()
                                    filehash = hashlib.sha256(putty_data).hexdigest()
                                    if sig_match(filehash) == 1:
                                        os.remove(newPath)
                                        self.Scanlog.emit(newPath + " 特征匹配 风险文件 已清除")
                                        count_bad = count_bad + 1
                                        malwarelist.append(newPath)
                                    else:
                                        result = (classifier.predict_sample(lgbm_model, putty_data))
                                        if result >= 0.9:
                                            os.remove(newPath)
                                            self.Scanlog.emit(newPath + " 模型检测 风险文件 已清除")
                                            count_bad = count_bad + 1
                                            malwarelist.append(newPath)
                                            filehash_signatures(filehash)
                                        else:
                                            self.Scanlog.emit(newPath + " 良性文件 不处理")
                                else:
                                    self.Scanlog.emit(newPath)
                            else:
                                self.Scanlog.emit(newPath)
                    except Exception as e:
                        self.Scanlog.emit(str(e))
        endtime = time.time()
        self.Scanlog.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + "快速扫描结束............................\n-----------------------------------------------------------")
        total_time = str(round(endtime - starttime, 2))
        self.status_scan.emit(total_time,count_files,count_bad,malwarelist)

    def stop(self,sign):
        self.sign = sign

class Thread_AllScan(QThread):
    Scanlog_ALL = pyqtSignal(str)
    status_scan_ALL = pyqtSignal(str,int,int,list)
    sign = 0
    def __init__(self):
        super(Thread_AllScan,self).__init__()

    def run(self):
        full_path = "C:/"
        count_files = 0
        count_bad = 0
        malwarelist = ['已清除以下恶意软件:']
        starttime = time.time()
        lgbm_model = lgb.Booster(model_file="model.txt")
        self.Scanlog_ALL.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + "开始全局扫描............................")
        for root, dirs,files in os.walk(full_path):
            if self.sign == 1:
                break
            for file in files:
                try:
                    if self.sign == 1:
                        break
                    dir2file = os.path.join(root, file)
                    size = os.path.getsize(dir2file)
                    winlist = dir2file.split('\\')
                    newPath = '/'.join(winlist)
                    count_files = count_files + 1
                    file_extension = filetype_scan(newPath)
                    if size <= 47185920:
                        if file_extension != 0 and file_extension == 'exe':
                            if os.path.splitext(file)[1] == '.exe' or '.' not in file:
                                putty_data = open(newPath, "rb").read()
                                filehash = hashlib.sha256(putty_data).hexdigest()
                                if sig_match(filehash) == 1:
                                    os.remove(newPath)
                                    self.Scanlog_ALL.emit(newPath + " 特征匹配 风险文件 已清除")
                                    count_bad = count_bad + 1
                                    malwarelist.append(newPath)
                                else:
                                    result = (classifier.predict_sample(lgbm_model, putty_data))
                                    if result >= 0.9:
                                        os.remove(newPath)
                                        self.Scanlog_ALL.emit(newPath + " 模型检测 风险文件 已清除")
                                        count_bad = count_bad + 1
                                        malwarelist.append(newPath)
                                        filehash_signatures(filehash)
                                    else:
                                        self.Scanlog_ALL.emit(newPath + " 良性文件 不处理")
                            else:
                                self.Scanlog_ALL.emit(newPath)
                        else:
                            self.Scanlog_ALL.emit(newPath)
                except Exception as e:
                    self.Scanlog_ALL.emit(str(e))
        endtime = time.time()
        self.Scanlog_ALL.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + "全局扫描结束............................\n-----------------------------------------------------------")
        total_time = str(round(endtime - starttime, 2))
        self.status_scan_ALL.emit(total_time,count_files,count_bad,malwarelist)

    def stop(self,sign):
        self.sign = sign


class ThreadCustomScan(QThread):
    Scanlog_Custom = pyqtSignal(str)
    status_scan_Custom = pyqtSignal(str,int,int,list)
    sign = 0
    def __init__(self,augmen_path):
        super(ThreadCustomScan,self).__init__()
        self.path = augmen_path

    def run(self):
        full_path = self.path
        count_files = 0
        count_bad = 0
        malwarelist = ['已清除以下恶意软件:']
        starttime = time.time()
        lgbm_model = lgb.Booster(model_file="model.txt")
        self.Scanlog_Custom.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + "开始扫描目录............................")
        for root, dirs,files in os.walk(full_path):
            if self.sign == 1:
                break
            for file in files:
                try:
                    if self.sign == 1:
                        break
                    dir2file = os.path.join(root, file)
                    size = os.path.getsize(dir2file)
                    winlist = dir2file.split('\\')
                    newPath = '/'.join(winlist)
                    count_files = count_files + 1
                    file_extension = filetype_scan(newPath)
                    if size <= 47185920:
                        if file_extension != 0 and file_extension == 'exe':
                            if os.path.splitext(file)[1] == '.exe' or '.' not in file:
                                putty_data = open(newPath, "rb").read()
                                filehash = hashlib.sha256(putty_data).hexdigest()
                                if sig_match(filehash) == 1:
                                    os.remove(newPath)
                                    self.Scanlog_Custom.emit(newPath + " 特征匹配 风险文件 已清除")
                                    count_bad = count_bad + 1
                                    malwarelist.append(newPath)
                                else:
                                    result = (classifier.predict_sample(lgbm_model, putty_data))
                                    if result >= 0.9:
                                        os.remove(newPath)
                                        self.Scanlog_Custom.emit(newPath + " 模型检测 风险文件 已清除")
                                        count_bad = count_bad + 1
                                        malwarelist.append(newPath)
                                        filehash_signatures(filehash)
                                    else:
                                        self.Scanlog_Custom.emit(newPath + " 良性文件 不处理")
                            else:
                                self.Scanlog_Custom.emit(newPath)
                        else:
                            self.Scanlog_Custom.emit(newPath)
                except Exception as e:
                    self.Scanlog_Custom.emit(str(e))
        endtime = time.time()
        self.Scanlog_Custom.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + "自定义扫描结束..........................\n-----------------------------------------------------------")
        total_time = str(round(endtime - starttime, 2))
        self.status_scan_Custom.emit(total_time,count_files,count_bad,malwarelist)

    def stop(self,sign):
        self.sign = sign

class ThreadFileMonitor(QThread):
    Monitorlog = pyqtSignal(str)
    Monitorinfo = pyqtSignal(str)
    def __init__(self):
        super(ThreadFileMonitor,self).__init__()

    def run(self):
        lgbm_model = lgb.Booster(model_file="model.txt")
        while 1:
            results = win32file.ReadDirectoryChangesW (
                                                    hDir,  #handle: Handle to the directory to be monitored. This directory must be opened with the FILE_LIST_DIRECTORY access right.
                                                    1024,  #size: Size of the buffer to allocate for the results.
                                                    True,  #bWatchSubtree: Specifies whether the ReadDirectoryChangesW function will monitor the directory or the directory tree.
                                                    win32con.FILE_NOTIFY_CHANGE_FILE_NAME |
                                                    win32con.FILE_NOTIFY_CHANGE_DIR_NAME |
                                                    win32con.FILE_NOTIFY_CHANGE_ATTRIBUTES |
                                                    win32con.FILE_NOTIFY_CHANGE_SIZE |
                                                    win32con.FILE_NOTIFY_CHANGE_LAST_WRITE |
                                                    win32con.FILE_NOTIFY_CHANGE_SECURITY,
                                                    None,
                                                    None)

            # time.sleep(0.1)
            if len(results):
                if results[0][0] == 1:
                    path = results[0][1]
                    winlist= path.split('\\')
                    newPath= '/'.join(winlist)
                    full_filename = "C:/" + newPath
                    if os.path.isdir(full_filename) is False:
                        try:
                            file_extension = filetype_scan(full_filename)
                            if file_extension != 0 and file_extension == 'exe':
                                putty_data = open(full_filename, "rb").read()
                                filehash = hashlib.sha256(putty_data).hexdigest()
                                if sig_match(filehash) == 1:
                                    os.remove(full_filename)
                                    self.Monitorlog.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + full_filename + " 特征匹配 风险文件 已清除")
                                    self.Monitorinfo.emit("发现风险文件" + full_filename + " 已清除")
                                else:
                                    result = (classifier.predict_sample(lgbm_model, putty_data))
                                    if result >= 0.9:
                                        os.remove(full_filename)
                                        self.Monitorlog.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + full_filename + " 模型检测 风险文件 已清除")
                                        self.Monitorinfo.emit("发现风险文件" + full_filename + " 已清除")
                                        filehash_signatures(filehash)
                                    else:
                                        self.Monitorlog.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + full_filename + " 良性文件 不处理")
                        except Exception as e:
                            self.Monitorlog.emit(str(e))
                    else:
                        for root, dirs,files in os.walk(full_filename):
                            for file in files:
                                try:
                                    dir2file = os.path.join(root, file)
                                    winlist = dir2file.split('\\')
                                    newPath = '/'.join(winlist)
                                    file_extension_dir = filetype_scan(newPath)
                                    if file_extension_dir != 0 and file_extension_dir == 'exe':
                                        putty_data = open(dir2file, "rb").read()
                                        filehash = hashlib.sha256(putty_data).hexdigest()
                                        if sig_match(filehash) == 1:
                                            os.remove(newPath)
                                            self.Monitorlog.emit(time.strftime("%Y-%m-%d %H:%M:%S ",time.localtime()) + full_filename + " 特征匹配 风险文件 已清除")
                                            self.Monitorinfo.emit("发现风险文件" + full_filename + " 已清除")
                                        else:
                                            lgbm_model = lgb.Booster(model_file="model.txt")
                                            result = (classifier.predict_sample(lgbm_model, putty_data))
                                            if result >= 0.9:
                                                os.remove(dir2file)
                                                self.Monitorlog.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + dir2file + " 模型检测 风险文件 已处理")
                                                self.Monitorinfo.emit("发现风险文件" + full_filename + " 已清除")
                                                filehash_signatures(filehash)

                                            else:
                                                self.Monitorlog.emit(time.strftime("%Y-%m-%d %H:%M:%S ", time.localtime()) + dir2file + " 良性文件 不处理")
                                except Exception as e:
                                    self.Monitorlog.emit(str(e))



class NotificationIcon:

    Info, Success, Warning, Error, Close = range(5)
    Types = {
        Info: None,
        Success: None,
        Warning: None,
        Error: None,
        Close: None
    }

    @classmethod
    def init(cls):
        cls.Types[cls.Info] = QPixmap(QImage.fromData(base64.b64decode('iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAC5ElEQVRYR8VX0VHbQBB9e/bkN3QQU0FMBSEVYFcQ8xPBJLJ1FWAqOMcaxogfTAWQCiAVRKkgTgfmM4zRZu6QhGzL0p0nDPr17e7bt7tv14RX/uiV48MJgAon+8TiAMRtMFogaqUJxADPwRRzg67kl8+xbWJWANR40iPQSSFgtX/mGQkaDr56V3VAKgGos4s2JXwJoF3naMPvMS+SrpTHs032GwGkdF+DsFMVnJm/oyGGeHico0EjIjpYes+YMyVd6R/flfkpBWCCQ9zaZM2LZDfLMGXsZ5kdI/lYBmINgHHyyLd1mWdBbAFAM/GY7K2WYx1AeB4T6L1N9umbGxZ0qktATaEAdCps48D39oq/LwEw3U5CN92LfczJoewfT7MAywDCaEbAuxeLrh0zz4L+0e4aAJfGy+sP3IMxlH1vpMJoSMCJDXgWtJeJVc6ACs9HBBrYODCJAFdYvAmkPJxnNqMwYht7Bn+T/lGg3z4DGEd3RPhQ54DBvwAOVkeqagRXfTLjh+x7+8sALOtfHLuiYzWOAiLoKbD58mnIGbCmLxUepS6NQmYlUGE0JeCTTXT9JvA9E9sZgO5iIpoyc6/YzcqSwQzgGgBXB7oXpH9klpRSkxY1xW/b7Iu2zk34PILPnazCqEPAtTWA8iZ0HsOu9L0bw4DzCJeNocMGNDpQ3IKO+6NUiJ4ysZNiBv5I3zPnmJmG5oM+wbS+9+qkvGi7NAXGmeUy0ioofa+XA0jH0UaMKpdRWs/adcwMqfV/tenqpqHY/Znt+j2gJi00RUzA201dXaxh9iZdZloJS+9H1otrkbRrD5InFqpPskxEshJQ468CkSmJC+i1HigaaxCAuCljgoDhwPdOjf7rFVxxuJrMkXScjtKc1rOLNpJk6nii5XmYzbngzlZn+RIb40kPJPTBYXUt6VEDJ8Pi6bWpNFb/jFYY6YGpDeKdjBmTKdMcxDGEmP73v2a2Gr/NOycGtglQZ/MPzEqCMLGckJEAAAAASUVORK5CYII=')))
        cls.Types[cls.Success] = QPixmap(QImage.fromData(base64.b64decode('iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACZUlEQVRYR8VXS3LTQBDtVsDbcAPMCbB3limkcAKSG4QFdnaYE2BOQLKzxSLJCeAGSUQheSnfwLmB2VJhXmpExpFHI2sk2RWv5FJPv9evP9NieuIfPzE+VSJw8qt3IMDvmahDoDYxt2UAACXMWIIowR5ffn8TJbaBWRE4CXvHAH9RgKXOgQUI48CfXZbZbiTw8Xe/w3d0zkydMkem91IZpyWOJu5sUXS+kEAqt3B+MNOLOuDqDEBLxxFHk7eza5MfIwEJDjhXTYD1s8zinYlEjsCD7FdNI9cJpEq0RFdPR47AMOzLCn69zegz6UgCP+pmfa8RSKudnPNdgCufTOLDxJtdPP7PoA1Cd8HEL5sSUCCD0B0x8bc1f8Bi6sevcgS2VXh6hMOwDz0gsUddNaxWKRjeuKfE/KlJ9Dq4UYH/o/Ns6scj+bgiMAjdayb26xLQwTfVEwg3gRcf6ARq578KuLo7VDc8psCQqwfjr4EfjYvkrAquFJ56UYpdSkAZSmNd1rrg0leOQFELgvA58OJTxVyRaAJORPOpF6UXnFUR5sDiXjs7UqsOMGMRlrWhTkJXpFL3mNrQZhA1lH3F0TiI5FurUQyMpn58VjhkSqQA4Tbw4nSVW6sBU5VXktXSeONlJH3s8jrOVr9RgVSFuNcWfzlh5n3LoKzMAPxxWuiULiQpiR2sZNnCyzIuWUr5Z1Ml0sgdHFZaShVDuR86/0huL3VXtDk/F4e11vKsTHLSCeKx7bYkW80hjLOrV1GhWH0ZrSlyh2MwdZhYfi8oZeYgLBmUiGd8sfVPM6syr2lUSYGaGBuP3QN6rVUwYV/egwAAAABJRU5ErkJggg==')))
        cls.Types[cls.Warning] = QPixmap(QImage.fromData(base64.b64decode('iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACmElEQVRYR8VXTW7TUBD+xjYSXZFukOIsSE9AskNJJMoJmq4r7OYEwAkabhBOkB/Emt4gVIojdpgbpIumEitX6gKB7UHPkauXxLHfc4F6Z3l+vvnmm/fGhAd+6IHzQwvA9cfOITMfAdQAcx1EdVEAM/tEFADsWyaPn57MfdXClABcT1qnzHSWJiwMzrwgoF91vXGRbS6AH59ajd8hDYmoURQo67tgxoij42rv62KX/04Agu44xmciVMokT32YERgGjquvZ1+y4mQCWPUa0/sk3vQlwqssEFsAVrQbU4XKL/ai2+5PPK6waQ4AOsoDnDARh83NdmwBuJq0fQI9L6p+L7rd3+/5gbAToMPI+FbkIzRRc72mbLcGIFE7jGFRIPHddmZrvstJh1X8CHGv6sxHqe1GkPYCoGcqgcoCAPPCdr2DLQC6wqMoPEj7qdqCNKllxs30sLpjYDluDUDGG5XqhY2sal3w4PiD7c7fJnHShMtJR8zpy/8CALiwndnhBgD1/t+XAXkaZAaUVHwnHulg0W6BNEWlAQD8zna8gQB0Ne70iXCm2j55jCUAei1gxvuaO+uXAcDg7zXHSy640iKUAehOEDJFqDmGQkiPLO5Fv+KADXOqvCuIsrPGsIyQdHou22YeRMJgOdHTQTkAfGk7XrLKrWlAvOhcRgBfWiZ3RQti0zxXuUFXCXMuo0TRitfxugjbIxC5RYzI6s9kIGFh+KLOpiW22id5AUuI8IaisFG4kCQg/sFKJgtPLix3KWXGeRETRbQDuCFCV2spTYMm+2FEI1WBbYIRPTeiqFtqLZeDraaD+qrbkpgQAvfl1WsXU0p/RjIjYYhTkNFgcCVlRlRKoAAc+5aF0V//NVPoc2kTLQZKZ8lx/AMXBmMwuXUwOAAAAABJRU5ErkJggg==')))
        cls.Types[cls.Error] = QPixmap(QImage.fromData(base64.b64decode('iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACrklEQVRYR82XW27aQBSG/4PtiNhIpStouoImKwjZAV1B07coWCpZQcgK6kh2lLeSFZSsIOwgdAdkBaUSEBQDpxpjU9vM+EJR03nDzJz/mzm3GcIrD3plfZQCeD47O1ho2jERNRmoE9AQG2BgBGBAwIiZe5Zh3JPjiG+5oxCAEF5q2iWITnMtRhOYu5XF4mr/9naYtSYXYGLbHQCXhYVTEwlom657rVqvBOB2uz71/a+ldq1SYe6ahnEhc4sSYGzbfQKOt915eh0D/ZrrnqS/SwEmrVYXRJ92Jb4OC+C65rrtuN0NgIltNwF837V4zN5Hy3V70e9NgFZrCKJ3CQDmJ9MwDsW36XzeB/AhA/CHqeuN2WxWX2paX2JraHneeynA+Pz8lCqVbxLjV5brimxAEJxqiEA8CjZVBvFy+bl2c9MV9hInoAw85qFpGEeRYQVEQjzMokcQHWxsiPne8jzh6j8AodGfyqNlHpiGcaKAkIk/gChwm2yYuv5W2FqfwLNtN5bAQ2bwySB83zENo50A8/1McaFRAU72XVek+mpk+D/JlIKI/xkee654uCbIhjVAqZIrgSgpLhiCwN4OAEj4vEB2yDybBCjsAol4ZD0nRdMQSRcUCsKUeNSw4o2mKMRGEOamoVx8FXDZKVosDYNMUHXAsBRnppo8RQcbpTgIGEkhykpFjnWxzGhPQYxt2yHgS/oIlKVYTJxImpG482nz+VG1Wh1N84pMCCGa0ULXHwmoJwCYnyzPW5fn/68dh7EgPbrMMl3gz7gro+n/7EoWD7w4a96l1NnJ1Yz5Lt6wCgFEk0r1CIkbiPnC9DxH5aHcd4FYGD5MOqVOg/muslh0/vphkm63k5eXZvA0I6qD+ZCI3jDzLxANiHn1NNvb6+30aVYgwLeeUsgFW1svsPA3Ncq4MHzVeO8AAAAASUVORK5CYII=')))
        cls.Types[cls.Close] = QPixmap(QImage.fromData(base64.b64decode(
            'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeElEQVQ4T2NkoBAwUqifgboGzJy76AIjE3NCWmL0BWwumzV/qcH/f38XpCfHGcDkUVwAUsDw9+8GBmbmAHRDcMlheAGbQnwGYw0DZA1gp+JwFUgKZyDCDQGpwuIlrGGAHHAUGUCRFygKRIqjkeKERE6+oG5eIMcFAOqSchGwiKKAAAAAAElFTkSuQmCC')))

    @classmethod
    def icon(cls, ntype):
        return cls.Types.get(ntype)


class NotificationItem(QWidget):

    closed = pyqtSignal(QListWidgetItem)

    def __init__(self, title, message, item, *args, ntype=0, callback=None, **kwargs):
        super(NotificationItem, self).__init__(*args, **kwargs)
        self.item = item
        self.callback = callback
        layout = QHBoxLayout(self, spacing=0)
        layout.setContentsMargins(0, 0, 0, 0)
        self.bgWidget = QWidget(self)  # 背景控件, 用于支持动画效果
        layout.addWidget(self.bgWidget)

        layout = QGridLayout(self.bgWidget)
        layout.setHorizontalSpacing(15)
        layout.setVerticalSpacing(10)

        # 标题左边图标
        layout.addWidget(
            QLabel(self, pixmap=NotificationIcon.icon(ntype)), 0, 0)

        # 标题
        self.labelTitle = QLabel(title, self)
        font = self.labelTitle.font()
        font.setBold(True)
        font.setPixelSize(21)
        self.labelTitle.setFont(font)

        # 关闭按钮
        self.labelClose = QLabel(
            self, cursor=Qt.PointingHandCursor, pixmap=NotificationIcon.icon(NotificationIcon.Close))

        # 消息内容
        self.labelMessage = QLabel(
            message, self, cursor=Qt.PointingHandCursor, wordWrap=True, alignment=Qt.AlignLeft | Qt.AlignTop)
        font = self.labelMessage.font()
        font.setPixelSize(18)
        self.labelMessage.setFont(font)
        self.labelMessage.adjustSize()

        # 添加到布局
        layout.addWidget(self.labelTitle, 0, 1)
        layout.addItem(QSpacerItem(
            40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum), 0, 2)
        layout.addWidget(self.labelClose, 0, 3)
        layout.addWidget(self.labelMessage, 1, 1, 1, 2)

        # 边框阴影
        effect = QGraphicsDropShadowEffect(self)
        effect.setBlurRadius(12)
        effect.setColor(QColor(0, 0, 0, 25))
        effect.setOffset(0, 2)
        self.setGraphicsEffect(effect)

        self.adjustSize()

        # 5秒自动关闭
        self._timer = QTimer(self, timeout=self.doClose)
        self._timer.setSingleShot(True)  # 只触发一次
        self._timer.start(5000)

    def doClose(self):
        try:
            # 可能由于手动点击导致item已经被删除了
            self.closed.emit(self.item)
        except:
            pass

    def showAnimation(self, width):
        # 显示动画
        pass

    def closeAnimation(self):
        # 关闭动画
        pass

    def mousePressEvent(self, event):
        super(NotificationItem, self).mousePressEvent(event)
        w = self.childAt(event.pos())
        if not w:
            return
        if w == self.labelClose:  # 点击关闭图标
            # 先尝试停止计时器
            self._timer.stop()
            self.closed.emit(self.item)
        elif w == self.labelMessage and self.callback and callable(self.callback):
            # 点击消息内容
            self._timer.stop()
            self.closed.emit(self.item)
            self.callback()  # 回调

    def paintEvent(self, event):
        # 圆角以及背景色
        super(NotificationItem, self).paintEvent(event)
        painter = QPainter(self)
        path = QPainterPath()
        path.addRoundedRect(QRectF(self.rect()), 6, 6)
        painter.fillPath(path, Qt.white)


class NotificationWindow(QListWidget):

    _instance = None

    def __init__(self, *args, **kwargs):
        super(NotificationWindow, self).__init__(*args, **kwargs)
        self.setSpacing(20)
        self.setMinimumWidth(550)
        self.setMaximumWidth(550)
        QApplication.instance().setQuitOnLastWindowClosed(True)
        # 隐藏任务栏,无边框,置顶等
        self.setWindowFlags(self.windowFlags() | Qt.Tool |
                            Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        # 去掉窗口边框
        self.setFrameShape(self.NoFrame)
        # 背景透明
        self.viewport().setAutoFillBackground(False)
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        # 不显示滚动条
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        # 获取屏幕高宽
        rect = QApplication.instance().desktop().availableGeometry(self)
        self.setMinimumHeight(rect.height())
        self.setMaximumHeight(rect.height())
        self.move(rect.width() - self.minimumWidth() - 18, 0)

    def removeItem(self, item):
        # 删除item
        w = self.itemWidget(item)
        self.removeItemWidget(item)
        item = self.takeItem(self.indexFromItem(item).row())
        w.close()
        w.deleteLater()
        del item

    @classmethod
    def _createInstance(cls):
        # 创建实例
        if not cls._instance:
            cls._instance = NotificationWindow()
            cls._instance.show()
            NotificationIcon.init()

    @classmethod
    def info(cls, title, message, callback=None):
        cls._createInstance()
        item = QListWidgetItem(cls._instance)
        w = NotificationItem(title, message, item, cls._instance,
                             ntype=NotificationIcon.Info, callback=callback)
        w.closed.connect(cls._instance.removeItem)
        item.setSizeHint(QSize(cls._instance.width() -
                               cls._instance.spacing(), w.height()))
        cls._instance.setItemWidget(item, w)

    @classmethod
    def success(cls, title, message, callback=None):
        cls._createInstance()
        item = QListWidgetItem(cls._instance)
        w = NotificationItem(title, message, item, cls._instance,
                             ntype=NotificationIcon.Success, callback=callback)
        w.closed.connect(cls._instance.removeItem)
        item.setSizeHint(QSize(cls._instance.width() -
                               cls._instance.spacing(), w.height()))
        cls._instance.setItemWidget(item, w)

    @classmethod
    def warning(cls, title, message, callback=None):
        cls._createInstance()
        item = QListWidgetItem(cls._instance)
        w = NotificationItem(title, message, item, cls._instance,
                             ntype=NotificationIcon.Warning, callback=callback)
        w.closed.connect(cls._instance.removeItem)
        item.setSizeHint(QSize(cls._instance.width() -
                               cls._instance.spacing(), w.height()))
        cls._instance.setItemWidget(item, w)

    @classmethod
    def error(cls, title, message, callback=None):
        cls._createInstance()
        item = QListWidgetItem(cls._instance)
        w = NotificationItem(title, message, item,
                             ntype=NotificationIcon.Error, callback=callback)
        w.closed.connect(cls._instance.removeItem)
        width = cls._instance.width() - cls._instance.spacing()
        item.setSizeHint(QSize(width, w.height()))
        cls._instance.setItemWidget(item, w)


class WidgetGallery(QMainWindow):
    sign_quick = pyqtSignal(int)
    sign_all = pyqtSignal(int)
    sign_custom = pyqtSignal(int)
    def __init__(self, parent=None):
        super(WidgetGallery, self).__init__(parent)
        #初始化窗口托盘
        self.tray_windows()
        # 初始化界面
        self.windows_layout()
        # 初始化文件监控
        self.filemonitor()

    def windows_layout(self):
        # 全局控件
        wwg = QWidget(self)
        #全局布局
        w1 = QVBoxLayout(wwg)
        h1 = QHBoxLayout()
        h2 = QHBoxLayout()
        h3 = QHBoxLayout()
        h2_quick = QVBoxLayout()
        h2_all = QVBoxLayout()
        h2_custom = QVBoxLayout()
        #添加控件
        self.quick_button = QPushButton()
        self.quick_button.setMaximumSize(150,150)
        self.quick_button.setMinimumSize(150,150)
        self.quick_button.setIcon(QIcon(QPixmap("./statics/image/quick.png")))
        self.quick_button.setStyleSheet("QPushButton{border:0px;font-size:20px;font-weight:text}QPushButton:pressed{background-color: rgb(217,217,217);border-radius: 10px;}")
        self.quick_button.setIconSize(QSize(113, 115))
        self.quick_button.setCheckable(True)
        self.quick_button.clicked.connect(self.quickscan)
        self.all_button = QPushButton()
        self.all_button.setMaximumSize(150,150)
        self.all_button.setMinimumSize(150,150)
        self.all_button.setIcon(QIcon(QPixmap("./statics/image/whole.png")))
        self.all_button.setStyleSheet("QPushButton{border:0px;font-size:20px;font-weight:text}QPushButton:pressed{background-color: rgb(217,217,217);border-radius: 10px;}")
        self.all_button.setIconSize(QSize(125, 125))
        self.all_button.setCheckable(True)
        self.all_button.clicked.connect(self.allscan)
        self.custom_button = QPushButton()
        self.custom_button.setMaximumSize(150,150)
        self.custom_button.setMinimumSize(150,150)
        self.custom_button.setIcon(QIcon(QPixmap("./statics/image/custom .png")))
        self.custom_button.setStyleSheet("QPushButton{border:0px;font-size:20px;font-weight:text}QPushButton:pressed{background-color: rgb(217,217,217);border-radius: 10px;}")
        self.custom_button.setIconSize(QSize(125, 125))
        # self.custom_button.setCheckable(True)
        self.custom_button.clicked.connect(self.customscan)
        self.custom_undo = QPushButton()
        self.custom_undo.setMaximumSize(150,150)
        self.custom_undo.setMinimumSize(150,150)
        self.custom_undo.setIcon(QIcon(QPixmap("./statics/image/undo.png")))
        self.custom_undo.setStyleSheet("QPushButton{border:0px;font-size:20px;font-weight:text}QPushButton:pressed{background-color: rgb(217,217,217);border-radius: 10px;}")
        self.custom_undo.setIconSize(QSize(147,147))
        self.custom_undo.setVisible(False)
        self.custom_undo.clicked.connect(self.customundo)


        self.time_label= QLabel(self)
        self.time_label.setText('当前扫描用时:  ')
        self.filenum_label = QLabel(self)
        self.filenum_label.setText('扫描文件数:  ')
        self.malnum_label = QLabel(self)
        self.malnum_label.setText('检测到恶意软件数:  ')

        self.time_show = QLabel(self)
        self.time_show.setText('00.00 secs')
        self.filenum_show = QLabel(self)
        self.filenum_show.setText('0 个')
        self.malnum_show = QLabel(self)
        self.malnum_show.setText('0 个')

        self.quick_bg = QLabel(self)
        self.quick_bg.setText('快速扫描')
        self.quick_bg.setStyleSheet("QLabel{font-size:20px;text-align : center;}")
        self.all_bg = QLabel(self)
        self.all_bg.setText('全局扫描')
        self.all_bg.setStyleSheet("QLabel{font-size:20px;text-align : center;}")
        self.custom_bg = QLabel(self)
        self.custom_bg.setText('自定义扫描')
        self.custom_bg.setStyleSheet("QLabel{font-size:20px;text-align : center;}")

        self.tab = QTabWidget()
        tab_more = QWidget()
        tab_results = QWidget()
        tab_defense = QWidget()

        self.scan_text = QTextBrowser()
        self.scan_text.setText('全局扫描:扫描本地所有的PE文件\n快速扫描:仅扫描系统关键路径下的PE文件\n自定义扫描:扫描指定路径下所有PE文件\n-----------------------------------------------------------')
        self.scan_text.setStyleSheet("QTextBrowser{border-width:0;border-style:outset}")
        tab_results_layout = QHBoxLayout()
        tab_results_layout.addWidget(self.scan_text)
        tab_results.setLayout(tab_results_layout)

        self.defense_text = QTextBrowser()
        self.defense_text.setText('')
        self.defense_text.setStyleSheet("QTextBrowser{border-width:0;border-style:outset}")
        tab_defense_layout = QHBoxLayout()
        tab_defense_layout.addWidget(self.defense_text)
        tab_defense.setLayout(tab_defense_layout)

        self.more_text = QTextBrowser()
        self.more_text.setText('尽请期待.....\n作者博客：yuque.com/qomumu\n联系邮箱：qomumu@foxmail.com')
        tab_more_layout = QHBoxLayout()
        tab_more_layout.addWidget(self.more_text)
        tab_more.setLayout(tab_more_layout)

        self.tab.addTab(tab_results,"扫描信息")
        self.tab.addTab(tab_defense,"文件监控")
        self.tab.addTab(tab_more,"更多模块...")

        #为局部布局添加控件
        h1.addWidget(self.time_label)
        h1.addWidget(self.time_show)
        h1.addStretch(1)
        h1.addWidget(self.filenum_label)
        h1.addWidget(self.filenum_show)
        h1.addStretch(1)
        h1.addWidget(self.malnum_label)
        h1.addWidget(self.malnum_show)
        h1.addStretch(10)
        h2.addStretch(1)
        h2_quick.addWidget(self.quick_button,0,Qt.AlignHCenter | Qt.AlignVCenter)
        h2_quick.setSpacing(0)
        h2_quick.addWidget(self.quick_bg,0,Qt.AlignHCenter | Qt.AlignVCenter)
        h2.addLayout(h2_quick)
        h2.addStretch(2)
        h2_all.addWidget(self.all_button,0,Qt.AlignHCenter | Qt.AlignVCenter)
        h2_all.setSpacing(0)
        h2_all.addWidget(self.all_bg,0,Qt.AlignHCenter | Qt.AlignVCenter)
        h2.addLayout(h2_all)
        h2.addStretch(2)
        h2_custom.addWidget(self.custom_button,0,Qt.AlignHCenter | Qt.AlignVCenter)
        h2_custom.addWidget(self.custom_undo,0,Qt.AlignHCenter | Qt.AlignVCenter)
        h2_custom.setSpacing(0)
        h2_custom.addWidget(self.custom_bg,0,Qt.AlignHCenter | Qt.AlignVCenter)
        h2.addLayout(h2_custom)
        h2.addStretch(1)
        h3.addWidget(self.tab)

        #将局部布局嵌套在全局布局中
        w1.addLayout(h1)
        w1.setSpacing(0)
        w1.addLayout(h2)
        w1.setSpacing(15)
        w1.addLayout(h3)

        #将全局布局设为中心控件
        widget = QWidget()
        widget.setLayout(w1)
        self.setCentralWidget(widget)

    def tray_windows(self):
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(QIcon('./statics/image/safe.ico'))

        show_action = QAction("显示", self)
        quit_action = QAction("退出", self)
        hide_action = QAction("隐藏", self)
        show_action.triggered.connect(self.show)
        hide_action.triggered.connect(self.hide)
        quit_action.triggered.connect(qApp.quit)
        tray_menu = QMenu()
        tray_menu.addAction(show_action)
        tray_menu.addAction(hide_action)
        tray_menu.addAction(quit_action)
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()

    def closeEvent(self, event):
        event.ignore()
        self.hide()
        self.tray_icon.showMessage(
            "MalwareDetection",
            "File monitoring is still in progress",
            QSystemTrayIcon.Information,
            2000
        )
    def quickscan(self):
        self._ThreadQuickScan = Thread_QuickScan()
        self.sign_quick.connect(self._ThreadQuickScan.stop)
        if self.quick_button.isChecked():
            self._ThreadQuickScan.start()
            self._ThreadQuickScan.Scanlog.connect(self.textbrower_scan)
            self._ThreadQuickScan.status_scan.connect(self.label_scan)
            self._ThreadQuickScan.status_scan.connect(self.success)
        else:
            self.sign_quick.emit(1)

    def allscan(self):
        self._ThreadAllScan = Thread_AllScan()
        self.sign_all.connect(self._ThreadAllScan.stop)
        if self.all_button.isChecked():
            self._ThreadAllScan.start()
            self._ThreadAllScan.Scanlog_ALL.connect(self.textbrower_scan)
            self._ThreadAllScan.status_scan_ALL.connect(self.label_scan)
            self._ThreadAllScan.status_scan_ALL.connect(self.success)
        else:
            self.sign_all.emit(1)

    def customscan(self):
        # if self.custom_button.isChecked():
        path = self.getdir()
        if len(path) != 0:
            self._ThreadCustomScan = ThreadCustomScan(path)
            self.sign_custom.connect(self._ThreadCustomScan.stop)
            self.scan_text.append("已选取目录:" + path)
            self._ThreadCustomScan.start()
            self._ThreadCustomScan.Scanlog_Custom.connect(self.textbrower_scan)
            self._ThreadCustomScan.status_scan_Custom.connect(self.label_scan)
            self._ThreadCustomScan.status_scan_Custom.connect(self.success)
            self.custom_button.setVisible(False)
            self.custom_undo.setVisible(True)
        # else:
        #     self.sign_custom.emit(1)
    def customundo(self):
        self.sign_custom.emit(1)
        self.custom_button.setVisible(True)
        self.custom_undo.setVisible(False)

    def filemonitor(self):
        self._ThreadFileMonitor = ThreadFileMonitor()
        self._ThreadFileMonitor.start()
        self._ThreadFileMonitor.Monitorlog.connect(self.label_defense)
        self._ThreadFileMonitor.Monitorinfo.connect(self.Monitor)

    def textbrower_scan(self, str):
        # 由于自定义信号时自动传递一个字符串参数，所以在这个槽函数中要接受一个参数
        self.scan_text.append(str)

    def label_scan(self,time_str,int1,int2,list):
        if int2 != 0:
            for result in list:
                self.scan_text.append(str(result))
        self.time_show.setText((time_str + " secs"))
        self.filenum_show.setText(str(int1) + "个")
        self.malnum_show.setText(str(int2)+ "个")

    def label_defense(self,log):
        self.defense_text.append(str(log))

    def getdir(self):
        directory = QFileDialog.getExistingDirectory(None,"选取文件夹","C:/")  # 起始路径
        return  directory

    def success(self,str1,str2,str3):
        file = str(str2)
        count = str(str3)
        self.custom_undo.setVisible(False)
        self.custom_button.setVisible(True)
        NotificationWindow.success('扫描结束',"耗时:" + str1 + ", 共扫描" + file + "个文件, " + "其中包含" + count + "个恶意软件")

    def Monitor(self,str):
        NotificationWindow.warning('文件监控',str)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    QApplication.setStyle(QStyleFactory.create("Fusion"))
    gallery = WidgetGallery()
    gallery.resize(900, 550)
    gallery.setWindowIcon(QIcon('./statics/image/safe.ico'))
    gallery.setWindowTitle("Malware Detection")
    gallery.setWindowOpacity(0.99)
    gallery.show()
    sys.exit(app.exec_())
