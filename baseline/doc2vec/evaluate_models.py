import os
import numpy as np
from sklearn.metrics import accuracy_score, precision_score, f1_score, recall_score, roc_auc_score,roc_curve
from sklearn.ensemble import RandomForestClassifier as RF
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import BernoulliNB,GaussianNB ,MultinomialNB
from sklearn.linear_model import LogisticRegression
from sklearn import tree
import torch.utils.data
import lightgbm as lgbm
from sklearn import svm
import matplotlib.pyplot as plt


class MalwareData(torch.utils.data.Dataset):
    def __init__(self, x, y):
        self.x = np.asarray(x)
        self.y = np.asarray(y)

    def __getitem__(self, item):
        x = self.x[item]
        y = self.y[item]

        x = torch.from_numpy(x)

        return x.float(), y

    def __len__(self):
        return len(self.x)

def get_dataset(path):
    """
    Get dataset from training path or test path.
    :param path: The path of .asm.vec files.
    :return: Training dataset or test dataset.
    """
    x = []
    y = []
    dirs = os.listdir(path)
    for dir in dirs:
        for vec in os.listdir(path + dir):
            x.append(np.loadtxt(path + dir + '/' + vec))
            y.append(int(dir) - 1)

    return MalwareData(x, y)

dataset = get_dataset('./vec/train/')
x_train, y_train = dataset.x, dataset.y
dataset = get_dataset('./vec/test/')
x_test, y_test = dataset.x, dataset.y

print('DecisionTree-doc2vec训练测试子集--------')

DT = tree.DecisionTreeClassifier()
DT.fit(x_train, y_train)
y_predict = DT.predict(x_test)

# fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
accuracy = accuracy_score(y_test, y_predict)
precision = precision_score(y_test, y_predict, average='weighted')
recall = recall_score(y_test, y_predict, average='weighted')
f1 = f1_score(y_test, y_predict, average='weighted')
print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
print('accuracy:', accuracy)
print('precision:', precision)
print('recall:', recall)
print('f1-score:', f1)
# plt.plot(fpr, tpr)
# plt.show()

print('LinearSVC-doc2vec训练测试子集----------')

svm=svm.SVC(kernel='linear', C=1000)
svm.fit(x_train, y_train)
y_predict = svm.predict(x_test)

# fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
accuracy = accuracy_score(y_test, y_predict)
precision = precision_score(y_test, y_predict, average='weighted')
recall = recall_score(y_test, y_predict, average='weighted')
f1 = f1_score(y_test, y_predict, average='weighted')
print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
print('accuracy:', accuracy)
print('precision:', precision)
print('recall:', recall)
print('f1-score:', f1)
# plt.plot(fpr, tpr)
# plt.show()

print('KNeighbors-doc2vec训练测试子集---------')

knn = KNeighborsClassifier()
knn.fit(x_train, y_train)
y_predict = knn.predict(x_test)

# fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
accuracy = accuracy_score(y_test, y_predict)
precision = precision_score(y_test, y_predict, average='weighted')
recall = recall_score(y_test, y_predict, average='weighted')
f1 = f1_score(y_test, y_predict, average='weighted')
print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
print('accuracy:', accuracy)
print('precision:', precision)
print('recall:', recall)
print('f1-score:', f1)
# plt.plot(fpr, tpr)
# plt.show()

# print('MultinomialNB-doc2vec训练测试子集------')
#
# bayes = MultinomialNB(alpha=0.01)
# bayes.fit(x_train, y_train)
# y_predict = bayes.predict(x_test)
#
# # fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
# accuracy = accuracy_score(y_test, y_predict)
# precision = precision_score(y_test, y_predict, average='weighted')
# recall = recall_score(y_test, y_predict, average='weighted')
# f1 = f1_score(y_test, y_predict, average='weighted')
# # print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
# print('accuracy:', accuracy)
# print('precision:', precision)
# print('recall:', recall)
# print('f1-score:', f1)
# # plt.plot(fpr, tpr)
# # plt.show()

print('BernoulliNB-doc2vec训练测试子集------')

bayes = BernoulliNB()
bayes.fit(x_train, y_train)
y_predict = bayes.predict(x_test)

# fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
accuracy = accuracy_score(y_test, y_predict)
precision = precision_score(y_test, y_predict, average='weighted')
recall = recall_score(y_test, y_predict, average='weighted')
f1 = f1_score(y_test, y_predict, average='weighted')
print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
print('accuracy:', accuracy)
print('precision:', precision)
print('recall:', recall)
print('f1-score:', f1)
# plt.plot(fpr, tpr)
# plt.show()

print('GaussianNB-doc2vec训练测试子集------')

bayes = GaussianNB()
bayes.fit(x_train, y_train)
y_predict = bayes.predict(x_test)

# fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
accuracy = accuracy_score(y_test, y_predict)
precision = precision_score(y_test, y_predict, average='weighted')
recall = recall_score(y_test, y_predict, average='weighted')
f1 = f1_score(y_test, y_predict, average='weighted')
print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
print('accuracy:', accuracy)
print('precision:', precision)
print('recall:', recall)
print('f1-score:', f1)
# plt.plot(fpr, tpr)
# plt.show()

print('LRegression-doc2vec训练测试子集-----')

LR = LogisticRegression()
LR.fit(x_train, y_train)
y_predict = LR.predict(x_test)

# fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
accuracy = accuracy_score(y_test, y_predict)
precision = precision_score(y_test, y_predict, average='weighted')
recall = recall_score(y_test, y_predict, average='weighted')
f1 = f1_score(y_test, y_predict, average='weighted')
print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
print('accuracy:', accuracy)
print('precision:', precision)
print('recall:', recall)
print('f1-score:', f1)
# plt.plot(fpr, tpr)
# plt.show()

print('RandomForest-doc2vec训练测试子集-------')

rf = RF()
rf.fit(x_train, y_train)
y_predict = rf.predict(x_test)

# fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
accuracy = accuracy_score(y_test, y_predict)
precision = precision_score(y_test, y_predict, average='weighted')
recall = recall_score(y_test, y_predict, average='weighted')
f1 = f1_score(y_test, y_predict, average='weighted')
print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
print('accuracy:', accuracy)
print('precision:', precision)
print('recall:', recall)
print('f1-score:', f1)
# plt.plot(fpr, tpr)
# plt.show()

print('LightGBM-doc2vec训练测试子集------------')

evals_result = {}

lgb = lgbm.LGBMClassifier()
lgb.fit(x_train, y_train)
y_predict = lgb.predict(x_test)

# fpr, tpr, thresholds = roc_curve(y_test, y_predict, pos_label=0)
accuracy = accuracy_score(y_test, y_predict)
precision = precision_score(y_test, y_predict, average='weighted')
recall = recall_score(y_test, y_predict, average='weighted')
f1 = f1_score(y_test, y_predict, average='weighted')
print('roc_auc_score:' , roc_auc_score(y_test, y_predict))
print('accuracy:', accuracy)
print('precision:', precision)
print('recall:', recall)
print('f1-score:', f1)

# plt.plot(fpr, tpr)
# plt.show()

# ax = lgbm.plot_importance(lgb, max_num_features=10)#max_features表示最多展示出前10个重要性特征，可以自行设置
# plt.show()

# ax = lgbm.plot_metric(evals_result, metric='auc')#metric的值与之前的params里面的值对应
# plt.show()

